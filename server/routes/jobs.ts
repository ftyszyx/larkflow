import { Hono } from "hono";
import { and, asc, eq, sql } from "drizzle-orm";
import { db } from "../db.ts";
import { articlePublications, articles, integrations, jobs } from "../drizzle/schema.ts";
import { JobQueue } from "../constants/jobs.ts";
import { requireUser } from "../middleware/auth.ts";
import { requireRole, requireWorkspace, requireWorkspaceMember } from "../middleware/workspace.ts";
import type { AppEnv } from "../types.ts";
import { fail, ok } from "../utils/response.ts";

export const jobRoutes = new Hono<AppEnv>();

jobRoutes.post(
    "/jobs/sync/feishu",
    requireUser,
    requireWorkspace,
    requireWorkspaceMember,
    requireRole(["owner", "admin", "member"]),
    async (c) => {
        const workspaceId = c.get("workspaceId") as number;
        const body = (await c.req.json().catch(() => null)) as null | {
            integrations_id?: number;
            feishu_doc_token?: string;
        };
        if (!body) return fail(c, 400, "invalid json");

        const integrationId = Number(body.integrations_id);
        const feishuDocToken = String(body.feishu_doc_token ?? "").trim();
        if (!Number.isFinite(integrationId)) return fail(c, 400, "integrations_id is required");
        if (!feishuDocToken) return fail(c, 400, "feishu_doc_token is required");

        const [integration] = await db
            .select({ id: integrations.id })
            .from(integrations)
            .where(and(eq(integrations.id, integrationId), eq(integrations.workspaceId, workspaceId)))
            .limit(1);
        if (!integration) return fail(c, 404, "integration not found");

        const jobKey = `${integrationId}:${feishuDocToken}`;
        const [existingJob] = await db
            .select({ id: jobs.id, queue: jobs.queue, scheduledAt: jobs.scheduledAt })
            .from(jobs)
            .where(and(eq(jobs.workspaceId, workspaceId), eq(jobs.queue, JobQueue.SyncFeishuSpace), eq(jobs.jobKey, jobKey)))
            .limit(1);
        if (existingJob) return fail(c, 409, "duplicate job", 409, { existing: existingJob });

        const jobRows = await db
            .insert(jobs)
            .values({
                workspaceId,
                jobKey,
                queue: JobQueue.SyncFeishuSpace,
                payload: {
                    type: JobQueue.SyncFeishuSpace,
                    workspaceId,
                    integrationId,
                    docToken: feishuDocToken,
                },
            })
            .returning({ id: jobs.id, queue: jobs.queue, scheduledAt: jobs.scheduledAt });

        return ok(c, jobRows[0], 201);
    },
);

jobRoutes.post(
    "/jobs/publish/article",
    requireUser,
    requireWorkspace,
    requireWorkspaceMember,
    requireRole(["owner", "admin", "member"]),
    async (c) => {
        const workspaceId = c.get("workspaceId") as number;
        const body = (await c.req.json().catch(() => null)) as null | {
            article_id?: number;
            integrations_id?: number;
        };
        if (!body) return fail(c, 400, "invalid json");

        const articleId = Number(body.article_id);
        const integrationId = Number(body.integrations_id);
        if (!Number.isFinite(articleId)) return fail(c, 400, "article_id is required");
        if (!Number.isFinite(integrationId)) return fail(c, 400, "integrations_id is required");

        const [article] = await db
            .select({ id: articles.id })
            .from(articles)
            .where(and(eq(articles.id, articleId), eq(articles.workspaceId, workspaceId)))
            .limit(1);
        if (!article) return fail(c, 404, "article not found");

        const [integration] = await db
            .select({ id: integrations.id })
            .from(integrations)
            .where(and(eq(integrations.id, integrationId), eq(integrations.workspaceId, workspaceId)))
            .limit(1);
        if (!integration) return fail(c, 404, "integration not found");

        const jobKey = `${integrationId}:${articleId}`;
        const [existingJob] = await db
            .select({ id: jobs.id, queue: jobs.queue, scheduledAt: jobs.scheduledAt })
            .from(jobs)
            .where(and(eq(jobs.workspaceId, workspaceId), eq(jobs.queue, JobQueue.PublishArticle), eq(jobs.jobKey, jobKey)))
            .limit(1);
        if (existingJob) return fail(c, 409, "duplicate job", 409, { existing: existingJob });

        const publicationRows = await db
            // schema.ts is generated by pull; during dev we may change SQL first.
            // deno-lint-ignore no-explicit-any
            .insert(articlePublications as any)
            .values({
                articleId,
                integrationId,
                status: "publishing",
            })
            .onConflictDoUpdate({
                // deno-lint-ignore no-explicit-any
                target: [(articlePublications as any).articleId, (articlePublications as any).integrationId],
                set: {
                    status: "publishing",
                    updatedAt: sql`now()`,
                },
            })
            .returning({ id: articlePublications.id, status: articlePublications.status });

        const jobRows = await db
            .insert(jobs)
            .values({
                workspaceId,
                jobKey,
                queue: JobQueue.PublishArticle,
                payload: {
                    type: JobQueue.PublishArticle,
                    workspaceId,
                    articleId,
                    integrationId,
                },
            })
            .returning({ id: jobs.id, queue: jobs.queue, scheduledAt: jobs.scheduledAt });

        return ok(c, { publication: publicationRows[0], job: jobRows[0] }, 201);
    },
);

jobRoutes.get(
    "/jobs",
    requireUser,
    requireWorkspace,
    requireWorkspaceMember,
    async (c) => {
        const workspaceId = c.get("workspaceId") as number;

        const queue = (c.req.query("queue") ?? "").trim();
        const limit = Math.min(Number(c.req.query("limit") ?? 50) || 50, 200);
        const offset = Math.max(Number(c.req.query("offset") ?? 0) || 0, 0);

        const where = queue ? and(eq(jobs.workspaceId, workspaceId), eq(jobs.queue, queue)) : eq(jobs.workspaceId, workspaceId);

        const data = await db
            .select()
            .from(jobs)
            .where(where)
            .orderBy(asc(jobs.scheduledAt))
            .limit(limit)
            .offset(offset);

        return ok(c, { items: data, limit, offset });
    },
);

jobRoutes.get(
    "/jobs/:id",
    requireUser,
    requireWorkspace,
    requireWorkspaceMember,
    async (c) => {
        const workspaceId = c.get("workspaceId") as number;
        const id = Number(c.req.param("id"));
        if (!Number.isFinite(id)) return fail(c, 400, "invalid id");

        const [row] = await db
            .select()
            .from(jobs)
            .where(and(eq(jobs.id, id), eq(jobs.workspaceId, workspaceId)))
            .limit(1);

        if (!row) return fail(c, 404, "not found");
        return ok(c, row);
    },
);

jobRoutes.post(
    "/jobs/:id/cancel",
    requireUser,
    requireWorkspace,
    requireWorkspaceMember,
    requireRole(["owner", "admin"]),
    async (c) => {
        const workspaceId = c.get("workspaceId") as number;
        const id = Number(c.req.param("id"));
        if (!Number.isFinite(id)) return fail(c, 400, "invalid id");

        const deleted = await db
            .delete(jobs)
            .where(and(eq(jobs.id, id), eq(jobs.workspaceId, workspaceId)))
            .returning({ id: jobs.id });

        if (deleted.length === 0) return fail(c, 404, "not found");
        return ok(c, deleted[0]);
    },
);

jobRoutes.post(
    "/jobs/:id/retry",
    requireUser,
    requireWorkspace,
    requireWorkspaceMember,
    requireRole(["owner", "admin"]),
    async (c) => {
        const workspaceId = c.get("workspaceId") as number;
        const id = Number(c.req.param("id"));
        if (!Number.isFinite(id)) return fail(c, 400, "invalid id");

        const updated = await db
            .update(jobs)
            .set({
                attempts: 0,
                lockedBy: null,
                lockedUntil: null,
                scheduledAt: new Date().toISOString(),
            })
            .where(and(eq(jobs.id, id), eq(jobs.workspaceId, workspaceId)))
            .returning({ id: jobs.id, scheduledAt: jobs.scheduledAt });

        if (updated.length === 0) return fail(c, 404, "not found");
        return ok(c, updated[0]);
    },
);
